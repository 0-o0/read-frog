name: Release

on:
  push:
    branches:
      - main

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          cache: pnpm

      - name: Install Dependencies
        run: pnpm install
        shell: bash

      - name: Create Release Pull Request or Tag
        id: changesets
        uses: changesets/action@v1
        with:
          commit: 'chore(release): version packages'
          title: 'chore(release): version packages'
          publish: pnpm run release
          createGithubReleases: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Send Discord Notification
        if: steps.changesets.outputs.published == 'true'
        run: |
          echo "Sending Discord notification for published packages..."

          # Get published packages from changesets output
          PUBLISHED_PACKAGES='${{ steps.changesets.outputs.publishedPackages }}'

          if [ -z "$PUBLISHED_PACKAGES" ] || [ "$PUBLISHED_PACKAGES" = "[]" ]; then
            echo "No packages were published"
            exit 0
          fi

          echo "Published packages: $PUBLISHED_PACKAGES"

          # Get the latest release tag to fetch release notes
          LATEST_TAG=$(git describe --abbrev=0 --tags 2>/dev/null || echo "")
          if [ -z "$LATEST_TAG" ]; then
            # Fallback to getting latest release from GitHub API
            LATEST_TAG=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest" \
              | jq -r '.tag_name // ""')
          fi

          echo "Latest tag: $LATEST_TAG"

          # Get release info and notes from GitHub API
          RELEASE_NOTES=""
          RELEASE_URL=""
          if [ -n "$LATEST_TAG" ] && [ "$LATEST_TAG" != "null" ]; then
            RELEASE_DATA=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases/tags/$LATEST_TAG")

            # Extract release notes and clean them up
            RELEASE_NOTES=$(echo "$RELEASE_DATA" | jq -r '.body // "No release notes available"')
            RELEASE_URL=$(echo "$RELEASE_DATA" | jq -r '.html_url // ""')

            # Remove HTML comments and format headers
            RELEASE_NOTES=$(echo "$RELEASE_NOTES" | sed 's/<!--[^>]*-->//g')
            RELEASE_NOTES=$(echo "$RELEASE_NOTES" | \
              sed 's/^## \(.*\)$/**\1**/g' | \
              sed 's/^### \(.*\)$/‚ñ∏ **\1**/g' | \
              sed 's/^#### \(.*\)$/  ‚Ä¢ **\1**/g' | \
              sed 's/^##### \(.*\)$/    ‚ó¶ **\1**/g')

            # Remove leading/trailing whitespace
            RELEASE_NOTES=$(echo "$RELEASE_NOTES" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

            # Limit to Discord embed limit (leaving room for other content)
            if [ ${#RELEASE_NOTES} -gt 800 ]; then
              RELEASE_NOTES=$(echo "$RELEASE_NOTES" | head -c 800)
              RELEASE_NOTES="${RELEASE_NOTES}..."
            fi
          fi

          # Build notification content for packages
          NOTIFICATION_CONTENT=""
          RELEASE_URLS=""

          # Get package emoji based on name
          get_package_emoji() {
            case "$1" in
              *"extension"*) echo "üì±" ;;
              *"website"*) echo "üåê" ;;
              *"cli"*) echo "‚ö°" ;;
              *"api"*) echo "üîå" ;;
              *"core"*) echo "‚öôÔ∏è" ;;
              *"sdk"*) echo "üõ†Ô∏è" ;;
              *) echo "üì¶" ;;
            esac
          }

          # Parse published packages JSON
          echo "$PUBLISHED_PACKAGES" | jq -c '.[]' | while read -r package_info; do
            if [ -n "$package_info" ]; then
              PACKAGE_NAME=$(echo "$package_info" | jq -r '.name')
              PACKAGE_VERSION=$(echo "$package_info" | jq -r '.version')

              # Generate tag name based on changesets convention
              PACKAGE_TAG="$PACKAGE_NAME@$PACKAGE_VERSION"

              EMOJI=$(get_package_emoji "$PACKAGE_NAME")
              # Extract display name (e.g., @read-frog/extension -> Extension)
              PACKAGE_DISPLAY_NAME=$(echo "$PACKAGE_NAME" | sed 's/.*\///g' | sed 's/\b\w/\U&/g')

              NOTIFICATION_CONTENT="$NOTIFICATION_CONTENT\n$EMOJI **$PACKAGE_DISPLAY_NAME** \`$PACKAGE_VERSION\`"
              RELEASE_URLS="$RELEASE_URLS\n[$PACKAGE_DISPLAY_NAME Release](https://github.com/${{ github.repository }}/releases/tag/$PACKAGE_TAG)"
            fi
          done

          # Properly escape release notes for JSON
          RELEASE_NOTES_ESCAPED=$(echo "$RELEASE_NOTES" | jq -Rs .)

          # Create Discord payload
          cat << EOF > /tmp/discord_payload.json
          {
            "embeds": [{
              "title": "üéâ New Release Published!",
              "description": "**${{ github.repository }}** has published new packages!",
              "url": "${RELEASE_URL:-https://github.com/${{ github.repository }}/releases}",
              "color": 48253,
              "fields": [
                {
                  "name": "üì¶ Published Packages",
                  "value": "$NOTIFICATION_CONTENT",
                  "inline": false
                },
                {
                  "name": "üîó Release Links",
                  "value": "$RELEASE_URLS",
                  "inline": false
                }$(if [ -n "$RELEASE_NOTES" ] && [ "$RELEASE_NOTES" != "No release notes available" ]; then echo ",
                {
                  \"name\": \"üìù Release Notes\",
                  \"value\": $RELEASE_NOTES_ESCAPED,
                  \"inline\": false
                }"; fi),
                {
                  "name": "üìÇ Repository",
                  "value": "[${{ github.repository }}](https://github.com/${{ github.repository }})",
                  "inline": true
                }$(if [ -n "$LATEST_TAG" ]; then echo ",
                {
                  \"name\": \"üè∑Ô∏è Version\",
                  \"value\": \"\\\`$LATEST_TAG\\\`\",
                  \"inline\": true
                }"; fi)
              ],
              "footer": {
                "text": "GitHub Actions",
                "icon_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
              },
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)"
            }]
          }
          EOF

          echo "Discord payload:"
          cat /tmp/discord_payload.json

          # Send to Discord
          curl -H "Content-Type: application/json" \
               -X POST \
               -d @/tmp/discord_payload.json \
               ${{ secrets.DISCORD_WEBHOOK_URL }}
