name: Release

on:
  push:
    branches:
      - main

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          cache: pnpm

      - name: Install Dependencies
        run: pnpm install
        shell: bash

      - name: Create Release Pull Request or Tag
        id: changesets
        uses: changesets/action@v1
        with:
          commit: 'chore(release): version packages'
          title: 'chore(release): version packages'
          publish: pnpm run release
          createGithubReleases: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Send Discord Notification
        if: steps.changesets.outputs.published == 'true'
        run: |
          echo "Sending Discord notification for published packages..."

          # Get published packages from changesets output
          PUBLISHED_PACKAGES='${{ steps.changesets.outputs.publishedPackages }}'

          if [ -z "$PUBLISHED_PACKAGES" ] || [ "$PUBLISHED_PACKAGES" = "[]" ]; then
            echo "No packages were published"
            exit 0
          fi

          echo "Published packages: $PUBLISHED_PACKAGES"

          # Get the latest release tag to fetch release notes
          LATEST_TAG=$(git describe --abbrev=0 --tags 2>/dev/null || echo "")
          if [ -z "$LATEST_TAG" ]; then
            # Fallback to getting latest release from GitHub API
            LATEST_TAG=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest" \
              | jq -r '.tag_name // ""')
          fi

          echo "Latest tag: $LATEST_TAG"

          # Get release info and notes from GitHub API
          RELEASE_NOTES_RAW=""
          RELEASE_URL=""
          if [ -n "$LATEST_TAG" ] && [ "$LATEST_TAG" != "null" ]; then
            RELEASE_DATA=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases/tags/$LATEST_TAG")

            # Extract release notes and clean them up
            RELEASE_NOTES_RAW=$(echo "$RELEASE_DATA" | jq -r '.body // "No release notes available"')
            RELEASE_URL=$(echo "$RELEASE_DATA" | jq -r '.html_url // ""')

            # Remove HTML comments and format headers
            if [ -n "$RELEASE_NOTES_RAW" ]; then
              RELEASE_NOTES_RAW=$(echo "$RELEASE_NOTES_RAW" | sed 's/<!--[^>]*-->//g')
              RELEASE_NOTES_RAW=$(echo "$RELEASE_NOTES_RAW" | \
                sed 's/^## \(.*\)$/**\1**/g' | \
                sed 's/^### \(.*\)$/‚ñ∏ **\1**/g' | \
                sed 's/^#### \(.*\)$/  ‚Ä¢ **\1**/g' | \
                sed 's/^##### \(.*\)$/    ‚ó¶ **\1**/g')

              # Remove leading/trailing whitespace
              RELEASE_NOTES_RAW=$(echo "$RELEASE_NOTES_RAW" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

              # Limit to Discord embed limit (leaving room for other content)
              if [ ${#RELEASE_NOTES_RAW} -gt 800 ]; then
                RELEASE_NOTES_RAW=$(echo "$RELEASE_NOTES_RAW" | head -c 800)
                RELEASE_NOTES_RAW="${RELEASE_NOTES_RAW}..."
              fi
            fi
          fi

          # Process each published package
          NOTIFICATION_EMBEDS="["
          FIRST_PACKAGE=true

          echo "$PUBLISHED_PACKAGES" | jq -c '.[]' | while read -r package_info; do
            if [ -n "$package_info" ]; then
              PACKAGE_NAME=$(echo "$package_info" | jq -r '.name')
              PACKAGE_VERSION=$(echo "$package_info" | jq -r '.version')

              # Generate tag name based on changesets convention
              PACKAGE_TAG="$PACKAGE_NAME@$PACKAGE_VERSION"

              # Get package emoji
              case "$PACKAGE_NAME" in
                *"extension"*) EMOJI="üê∏" ;;
                *"website"*) EMOJI="üåê" ;;
                *"cli"*) EMOJI="‚ö°" ;;
                *"api"*) EMOJI="üîå" ;;
                *"core"*) EMOJI="‚öôÔ∏è" ;;
                *"sdk"*) EMOJI="üõ†Ô∏è" ;;
                *) EMOJI="üì¶" ;;
              esac

              # Extract display name (e.g., @read-frog/extension -> Extension)
              PACKAGE_DISPLAY_NAME=$(echo "$PACKAGE_NAME" | sed 's/.*\///g' | sed 's/\b\w/\U&/g')

              TITLE="$EMOJI $PACKAGE_DISPLAY_NAME Release!"
              DESCRIPTION="**$PACKAGE_DISPLAY_NAME** version \`$PACKAGE_VERSION\` has been released!"

              # Build fields using jq
              if [ -n "$RELEASE_NOTES_RAW" ] && [ "$RELEASE_NOTES_RAW" != "No release notes available" ]; then
                FIELDS_JSON=$(jq -n \
                  --arg tag "$PACKAGE_TAG" \
                  --arg release_notes "$RELEASE_NOTES_RAW" \
                  '[
                    {
                      "name": "üè∑Ô∏è Tag",
                      "value": ("`" + $tag + "`"),
                      "inline": true
                    },
                    {
                      "name": "üìù Release Notes",
                      "value": $release_notes,
                      "inline": false
                    }
                  ]')
              else
                FIELDS_JSON=$(jq -n \
                  --arg tag "$PACKAGE_TAG" \
                  '[
                    {
                      "name": "üè∑Ô∏è Tag",
                      "value": ("`" + $tag + "`"),
                      "inline": true
                    }
                  ]')
              fi

              # Create individual embed
              TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%S.000Z)
              EMBED_JSON=$(jq -n \
                --arg title "$TITLE" \
                --arg description "$DESCRIPTION" \
                --arg url "${RELEASE_URL:-https://github.com/${{ github.repository }}/releases/tag/$PACKAGE_TAG}" \
                --argjson fields "$FIELDS_JSON" \
                --arg timestamp "$TIMESTAMP" \
                '{
                  title: $title,
                  description: $description,
                  url: $url,
                  color: 48253,
                  fields: $fields,
                  footer: {
                    text: "GitHub Actions",
                    icon_url: "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
                  },
                  timestamp: $timestamp
                }')

              # Add to embeds array (Discord supports up to 10 embeds)
              if [ "$FIRST_PACKAGE" = true ]; then
                NOTIFICATION_EMBEDS="[$EMBED_JSON"
                FIRST_PACKAGE=false
              else
                NOTIFICATION_EMBEDS="$NOTIFICATION_EMBEDS,$EMBED_JSON"
              fi
            fi
          done

          # Close the embeds array
          NOTIFICATION_EMBEDS="$NOTIFICATION_EMBEDS]"

          # Create final Discord payload
          echo "$NOTIFICATION_EMBEDS" | jq '{embeds: .}' > /tmp/discord_payload.json

          echo "Discord payload:"
          cat /tmp/discord_payload.json

          # Validate JSON before sending
          if ! jq empty /tmp/discord_payload.json 2>/dev/null; then
            echo "Error: Generated invalid JSON payload"
            exit 1
          fi

          # Send to Discord
          RESPONSE=$(curl -s -w "%{http_code}" -H "Content-Type: application/json" \
               -X POST \
               -d @/tmp/discord_payload.json \
               ${{ secrets.DISCORD_WEBHOOK_URL }})

          HTTP_CODE=$(echo "$RESPONSE" | tail -c 4)
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "‚úÖ Successfully sent Discord notification (HTTP $HTTP_CODE)"
          else
            echo "‚ùå Failed to send Discord notification (HTTP $HTTP_CODE)"
            echo "Response: $RESPONSE"
            exit 1
          fi
